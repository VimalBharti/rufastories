import{r as e,u as t,p as a,g as n,c as s,o,j as i,$ as c,a as d,e as l,h as u}from"../../../nitro/nitro.mjs";import{r as h}from"../../../_/auth.mjs";import"node:async_hooks";let y;function hubDatabase(){if(e("database"),y)return y;const c=t().hub,d=a.env.DB||globalThis.__env__?.DB||globalThis.DB;if(c.remote&&c.projectUrl&&!d){const t=n(c.cloudflareAccess);return y=function(t,a,n){e("database");const s=o.create({baseURL:i(t,"/api/_hub/database"),method:"POST",headers:{Authorization:`Bearer ${a}`,...n}});return{exec:async e=>s("/exec",{body:{query:e}}).catch(handleProxyError$1),prepare(e){const t={_body:{query:e,params:[]},bind:(...a)=>({...t,_body:{query:e,params:a}}),async all(){return s("/all",{body:this._body}).catch(handleProxyError$1)},async raw(e){return s("/raw",{body:{...this._body,...e}}).catch(handleProxyError$1)},async run(){return s("/run",{body:this._body}).catch(handleProxyError$1)},async first(e){return s("/first",{body:{...this._body,colName:e}}).catch(handleProxyError$1).then((e=>e||null))}};return t},batch:e=>s("/batch",{body:e.map((e=>e._body))})}}(c.projectUrl,c.projectSecretKey||c.userToken,t),y}if(d)return y=d,y;throw s("Missing Cloudflare DB binding (D1)")}function handleProxyError$1(e){throw s({statusCode:e.statusCode,message:e.data?.message||e.message})}function createError(e,t,a){const n=new Error(`[unstorage] [${e}] ${t}`,a);return Error.captureStackTrace&&Error.captureStackTrace(n,createError),n}const httpDriver=e=>{const r=(t="")=>i(e.base,t.replace(/:/g,"/")),rBase=(t="")=>i(e.base,(t||"/").replace(/:/g,"/"),":"),catchFetchError=(e,t=null)=>{if(404===e?.response?.status)return t;throw e},getHeaders=(t,a)=>{const n={...a,...e.headers,...t?.headers};return t?.ttl&&!n["x-ttl"]&&(n["x-ttl"]=t.ttl+""),n};return{name:"http",options:e,hasItem:(e,t)=>c(r(e),{method:"HEAD",headers:getHeaders(t)}).then((()=>!0)).catch((e=>catchFetchError(e,!1))),getItem:async(e,t)=>await c(r(e),{headers:getHeaders(t)}).catch(catchFetchError),getItemRaw:async(e,t)=>(await c.raw(r(e),{responseType:"arrayBuffer",headers:getHeaders(t,{accept:"application/octet-stream"})}).catch(catchFetchError))._data,async getMeta(e,t){const a=await c.raw(r(e),{method:"HEAD",headers:getHeaders(t)});let n,s;const o=a.headers.get("last-modified");o&&(n=new Date(o));const i=a.headers.get("x-ttl");return i&&(s=Number.parseInt(i,10)),{status:a.status,mtime:n,ttl:s}},async setItem(e,t,a){await c(r(e),{method:"PUT",body:t,headers:getHeaders(a)})},async setItemRaw(e,t,a){await c(r(e),{method:"PUT",body:t,headers:getHeaders(a,{"content-type":"application/octet-stream"})})},async removeItem(e,t){await c(r(e),{method:"DELETE",headers:getHeaders(t)})},async getKeys(e,t){const a=await c(rBase(e),{headers:getHeaders(t)});return Array.isArray(a)?a:[]},async clear(e,t){await c(rBase(e),{method:"DELETE",headers:getHeaders(t)})}}};function getKVBinding(e="STORAGE"){return function(e){let t="[binding]";if("string"==typeof e&&(t=e,e=globalThis[t]||globalThis.__env__?.[t]),!e)throw createError("cloudflare",`Invalid binding \`${t}\`: \`${e}\``);for(const a of["get","put","delete"])if(!(a in e))throw createError("cloudflare",`Invalid binding \`${t}\`: \`${a}\` key is missing`);return e}(e)}const cloudflareKVBindingDriver=e=>{const r=(t="")=>e.base?function(...e){return e.map((e=>function(e,t=":"){return e?e.replace(/[:/\\]/g,t).replace(/^[:/\\]|[:/\\]$/g,""):""}(e))).filter(Boolean).join(":")}(e.base,t):t;async function getKeys(t=""){t=r(t);const a=getKVBinding(e.binding),n=[];let s;do{const e=await a.list({prefix:t||void 0,cursor:s});n.push(...e.keys),s=e.list_complete?void 0:e.cursor}while(s);return n.map((e=>e.name))}return{name:"cloudflare-kv-binding",options:e,getInstance:()=>getKVBinding(e.binding),async hasItem(t){t=r(t);const a=getKVBinding(e.binding);return null!==await a.get(t)},getItem(t){t=r(t);return getKVBinding(e.binding).get(t)},setItem(t,a,n){t=r(t);return getKVBinding(e.binding).put(t,a,n?{expirationTtl:n?.ttl?Math.max(n.ttl,e.minTTL??60):void 0,...n}:void 0)},removeItem(t){t=r(t);return getKVBinding(e.binding).delete(t)},getKeys:t=>getKeys(t).then((t=>t.map((t=>e.base?t.slice(e.base.length):t)))),async clear(t){const a=getKVBinding(e.binding),n=await getKeys(t);await Promise.all(n.map((e=>a.delete(e))))}}};function hubKV(){e("kv");const o=t().hub,c=a.env.KV||globalThis.__env__?.KV||globalThis.KV;if(o.remote&&o.projectUrl&&!c){const t=n(o.cloudflareAccess);return function(t,a,n){e("kv");return d({driver:httpDriver({base:i(t,"/api/_hub/kv/"),headers:{Authorization:`Bearer ${a}`,...n}})})}(o.projectUrl,o.projectSecretKey||o.userToken,t)}if(c){return d({driver:cloudflareKVBindingDriver({binding:c})})}throw s("Missing Cloudflare KV binding (KV)")}const b={};function hubVectorize(c){if(e("vectorize"),b[c])return b[c];const d=t().hub,l=`VECTORIZE_${c.toUpperCase()}`,u=a.env[l]||globalThis.__env__?.[l]||globalThis[l];if(d.remote&&d.projectUrl&&!u){const t=n(d.cloudflareAccess);return b[c]=function(t,a,n,s){e("vectorize");const c=o.create({baseURL:i(a,`/api/_hub/vectorize/${t}`),method:"POST",headers:{Authorization:`Bearer ${n}`,...s}});return{insert:async e=>c("/insert",{body:{vectors:e}}).catch(handleProxyError),upsert:async e=>c("/upsert",{body:{vectors:e}}).catch(handleProxyError),query:async(e,t)=>c("/query",{body:{query:e,params:t}}).catch(handleProxyError),getByIds:async e=>c("/getByIds",{body:{ids:e}}).catch(handleProxyError),deleteByIds:async e=>c("/deleteByIds",{body:{ids:e}}).catch(handleProxyError),describe:async()=>c("/describe").catch(handleProxyError)}}(c,d.projectUrl,d.projectSecretKey||d.userToken,t),b[c]}if(u)return b[c]=u,b[c];throw s(`Missing Cloudflare Vectorize binding (${l})`)}function handleProxyError(e){throw s({statusCode:e.statusCode,message:e.data?.message||e.message})}const g=l((async e=>{await h(e);const{version:a,cache:n,ai:s,analytics:o,browser:i,blob:c,kv:d,database:l,vectorize:y}=t().hub,[b,g,f,m]=await Promise.all([falseIfFail((()=>l&&hubDatabase().exec("PRAGMA table_list"))),falseIfFail((()=>d&&hubKV().getKeys("__check__"))),falseIfFail((()=>c&&u().list({prefix:"__check__"}))),Promise.all(Object.keys(y).map((async e=>{const t=hubVectorize(e),a=await falseIfFail((()=>t.describe()));return[e,Boolean(a)]})))]),p=Object.fromEntries(Object.entries(y).filter((([e])=>m.find((([t,a])=>t===e&&a)))));return{version:a,storage:{database:Boolean(b),kv:Array.isArray(g),blob:Array.isArray(f?.blobs),vectorize:p},features:{ai:s,analytics:o,browser:i,cache:n}}}));async function falseIfFail(e){try{const t=e();return t instanceof Promise?t.catch((()=>!1)):t}catch(e){return!1}}export{g as default};
//# sourceMappingURL=manifest.get.mjs.map
